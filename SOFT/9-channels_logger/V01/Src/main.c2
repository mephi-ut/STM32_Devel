#define GPIO_PIN_0                 ((uint16_t)0x0001)  /* Pin 0 selected    */
#define GPIO_PIN_1                 ((uint16_t)0x0002)  /* Pin 1 selected    */
#define GPIO_PIN_2                 ((uint16_t)0x0004)  /* Pin 2 selected    */
#define GPIO_PIN_3                 ((uint16_t)0x0008)  /* Pin 3 selected    */
#define GPIO_PIN_4                 ((uint16_t)0x0010)  /* Pin 4 selected    */
#define GPIO_PIN_5                 ((uint16_t)0x0020)  /* Pin 5 selected    */
#define GPIO_PIN_6                 ((uint16_t)0x0040)  /* Pin 6 selected    */
#define GPIO_PIN_7                 ((uint16_t)0x0080)  /* Pin 7 selected    */
#define GPIO_PIN_8                 ((uint16_t)0x0100)  /* Pin 8 selected    */
#define GPIO_PIN_9                 ((uint16_t)0x0200)  /* Pin 9 selected    */
#define GPIO_PIN_10                ((uint16_t)0x0400)  /* Pin 10 selected   */
#define GPIO_PIN_11                ((uint16_t)0x0800)  /* Pin 11 selected   */
#define GPIO_PIN_12                ((uint16_t)0x1000)  /* Pin 12 selected   */
#define GPIO_PIN_13                ((uint16_t)0x2000)  /* Pin 13 selected   */
#define GPIO_PIN_14                ((uint16_t)0x4000)  /* Pin 14 selected   */
#define GPIO_PIN_15                ((uint16_t)0x8000)  /* Pin 15 selected   */


#include <stdint.h>
#include "stm32f103xb.h"

volatile uint32_t adc[10], res = 0, count = 0;
volatile uint8_t writebuff[512], cmd0[8]={0x40, 0x00, 0x00, 0x00, 0x00, 0x95, 0xFF, 0xFF}, rxne;

//void SD_SendCmd(uint8_t Cmd, uint32_t Arg, uint8_t Crc);

void  SD_SendCmd(uint8_t Cmd, uint32_t Arg, uint8_t Crc)
{
  uint32_t i = 0x00;

  uint8_t Frame[6];

  Frame[0] = (Cmd | 0x40); /*!< Construct byte 1 */

  Frame[1] = (uint8_t)(Arg >> 24); /*!< Construct byte 2 */

  Frame[2] = (uint8_t)(Arg >> 16); /*!< Construct byte 3 */

  Frame[3] = (uint8_t)(Arg >> 8); /*!< Construct byte 4 */

  Frame[4] = (uint8_t)(Arg); /*!< Construct byte 5 */

  Frame[5] = (Crc); /*!< Construct CRC: byte 6 */

  for (i = 0; i < 6; i++)
  {
    SPI2->DR = Frame[i]; /*!< Send the Cmd bytes */
  }

}


uint8_t SD_ReadByte(void)
{ 
  uint8_t Data = 0;

  /*!< Wait until the transmit buffer is empty */
  while ((SPI2->SR & 0x02) == 0x00)
  {
  }
  SPI2->DR = 0xFF;

  while ((SPI2->SR & 0x01) == 0x00)
  {
  }
  /*!< Get the received data */
  Data = SPI2->DR;

  /*!< Return the shifted data */
  return Data;
}



uint8_t SD_GetResponse(uint8_t Response){
 uint32_t Count = 0xFFF;
 uint32_t Rsp;
  /*!< Check if response is got or a timeout is happen */
  while ((Rsp = SD_ReadByte() != Response) && Count)
  {
    Count--;
  }
  if (Count == 0)
  {
    /*!< After time out */
    return Rsp;
  }
  else
  {
    /*!< Right response got */
    return Rsp;
  }

}





void Init_HW (void){

	RCC->APB2ENR |= (RCC_APB2ENR_IOPBEN | RCC_APB2ENR_AFIOEN );	// clock port b on
	RCC->APB1ENR |= RCC_APB1ENR_SPI2EN;// тактирование -  вклы!
	GPIOB->CRH &= ~(GPIO_CRH_CNF12 | GPIO_CRH_CNF13 | GPIO_CRH_CNF14 | GPIO_CRH_CNF15);

	GPIOB->CRH |= GPIO_CRH_CNF15_1 | GPIO_CRH_CNF13_1 | GPIO_CRH_CNF12_1 ;
	GPIOB->CRH |= GPIO_CRH_MODE15 | GPIO_CRH_MODE13 | GPIO_CRH_CNF12;

//	GPIOB->CRH = 0b10111001100100110000000000000000;

//	GPIOB->CRH |= GPIO_CRH_MODE12;

	GPIOB->CRH |= GPIO_CRH_CNF14_0;
	GPIOB->CRH &= ~GPIO_CRH_MODE14;



/*
	SPI2->CR1 |= SPI_CR1_BR;			// скорость обмена - клок/256
	SPI2->CR1 &= SPI_CR1_CPOL; 			// полярность (надо, чтобы были одинаковы и там и там)
	SPI2->CR1 &= SPI_CR1_CPHA; 			// фаза (надо, чтобы были одинаковы и там и там)
	SPI2->CR1 &= ~SPI_CR1_DFF; 			// передаём по 8 бит
	SPI2->CR1 &= ~SPI_CR1_LSBFIRST;			// MSB передаём первым
	SPI2->CR1 |= SPI_CR1_SSM;			// NSS управляется программно
	SPI2->CR1 |= SPI_CR1_SSI; 			// NSS в высокий уровень
	SPI2->CR2 |= SPI_CR2_SSOE;			// NSS рулит рабами
	SPI2->CR1 |= SPI_CR1_MSTR;			// врубаем режим господина
*/
	SPI2->CR1 = 0b0000001110100101;
	SPI2->CR1 |= SPI_CR1_SPE;			// SPI2 - вкыл!
	
	
	
	GPIOB->CRL &= ~GPIO_CRL_CNF2;					// port pb2 push-pull
	GPIOB->CRL |= GPIO_CRL_MODE2_0;					// port pb2 led out


	GPIOB->CRH &= ~GPIO_CRH_CNF12;					// port pb2 push-pull
	GPIOB->CRH |= GPIO_CRH_MODE12_0;					// port pb2 led out


	RCC->CFGR &= ~RCC_CFGR_ADCPRE;					// включили делитель
	RCC->CFGR |= RCC_CFGR_ADCPRE_DIV2;				// делитель на 2
	GPIOA -> CRL = 0b00000000000000000000000000000000;		// нижний порт А в режим входа
//	GPIOB ->CRL |= 0b001000100000;
//	GPIOB ->CRL &= ~0xcc;
	RCC->APB2ENR |= RCC_APB2ENR_IOPAEN;				// врубили тактирование порта А
	RCC->APB2ENR |= RCC_APB2ENR_ADC1EN;				// врубили тактирование АЦП
	ADC1->CR2 = ADC_CR2_EXTSEL_0 | ADC_CR2_EXTSEL_1 | ADC_CR2_EXTSEL_2 | ADC_CR2_EXTTRIG; // программные прерывания в приоритете
	ADC1->CR2 |= ADC_CR2_ADON;					// старт АЦП

	// перекалибровка
	GPIOB -> BSRR = GPIO_PIN_2;					// посветим процесс перекалибровки лампочкой :)

	// сброс калибровки
	ADC1->CR2 |= ADC_CR2_RSTCAL;					// сброс калибровки

	// ждём когда сбросится калибровка
	while ( ( ADC1->CR2 & ADC_CR2_RSTCAL ) == ADC_CR2_RSTCAL );	// ждём выполнения…

	// дождались, калибруем
	ADC1->CR2 |= ADC_CR2_CAL;					// калибровка
	while ( ( ADC1->CR2 & ADC_CR2_RSTCAL ) == ADC_CR2_CAL );	// ждём выполнения…

	// перекалибровка выполнена
	GPIOB -> BRR  = GPIO_PIN_2;					// тушим свет :)
}


int main ( void )
{

    Init_HW();

	for (int k=0;k<10000;k++);
    while (1){


	GPIOB->BSRR = GPIO_PIN_12;
	for(int i=0; i<80; i++){
	SPI2->DR = 0xFF;
//	for (int k=0; k<10;k++);
	}
//	
	GPIOB->BRR = GPIO_PIN_12;
	SD_SendCmd(0x40, 0, 0x95);
	SPI2->DR = 0xFF;
	while ((SPI2->SR) != 0x01);
	GPIOB->BSRR = GPIO_PIN_12;
	while ((SPI2->DR) == 0x01);

	while (1);
	
    }

}


